

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Design overview &#8212; h5cpp 0.4.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bizstyle.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Working with files" href="files.html" />
    <link rel="prev" title="Using the library" href="using.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="files.html" title="Working with files"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="using.html" title="Using the library"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">h5cpp 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Users guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Design overview</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="design-overview">
<span id="id1"></span><h1>Design overview<a class="headerlink" href="#design-overview" title="Permalink to this headline">¶</a></h1>
<p>This chapter will provide you with a short introduction in to HDF5 and its
unerlying concepts as well as <em>h5cpp</em>’s approach how to map these concepts
onto C++ classes.</p>
<section id="h5cpp-namespaces">
<h2><em>h5cpp</em> namespaces<a class="headerlink" href="#h5cpp-namespaces" title="Permalink to this headline">¶</a></h2>
<p>In order to use <em>h5cpp</em> you need to include the <code class="file docutils literal notranslate"><span class="pre">hdf5.hpp</span></code> header file
like this</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;h5cpp/hdf5.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>This will pull in everything you need. The entire library is organized in
several namespaces with a top level namespace <code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5</span></code></p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/hdf5_package_overview.svg"><img alt="../_images/hdf5_package_overview.svg" src="../_images/hdf5_package_overview.svg" width="85%" /></a>
</figure>
<p>Every namespace contains classes associated with a particular aspect of the
library and HDF5.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>namespace</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::property</span></code></p></td>
<td><p>namespace with property list implementations.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::attribute</span></code></p></td>
<td><p>contains all classes related to attributes and
attribute management.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::datatype</span></code></p></td>
<td><p>datatypes and related utility functions. The
classes in this namespace should not be
confused with <em>commited datatypes</em> which are
indeed nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::node</span></code></p></td>
<td><p>the most imporant namespace providing all
functionality to deal with nodes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::dataspace</span></code></p></td>
<td><p>dataspaces and related utilities</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::error</span></code></p></td>
<td><p>error management and exceptions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-any docutils literal notranslate"><span class="pre">hdf5::file</span></code></p></td>
<td><p>everything releated to files</p></td>
</tr>
</tbody>
</table>
<p>The top level namespace contains also some more esoteric classes like
<a class="reference internal" href="../api_reference/namespace_hdf5.html#_CPPv4N4hdf58ObjectIdE" title="hdf5::ObjectId"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::ObjectId</span></code></a> or <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ObjectHandle</span></code> which we can savely
ignore for now.</p>
<p>The most important classes in the top-level namspace might be
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::Dimensions</span></code> which is a type alias of the form</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">hsize_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>in order to get rid of the rather nasty</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">hsize_t</span><span class="w"> </span><span class="o">*</span><span class="n">dims</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>which is heavily used throughout the C-API and thus a rather potential source
for memory leaks. Using <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::vector</span></code> serves the same purpose but
is far less easier to use and avoids problems with memory leaks.</p>
</section>
<section id="a-high-level-view-on-hdf5">
<h2>A high level view on HDF5<a class="headerlink" href="#a-high-level-view-on-hdf5" title="Permalink to this headline">¶</a></h2>
<section id="nodes-links-and-paths">
<h3>Nodes, links, and paths<a class="headerlink" href="#nodes-links-and-paths" title="Permalink to this headline">¶</a></h3>
<p>An HDF5 tree can be considered a tree of objects connected by links.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/hdf5_basic_tree.svg"><img alt="../_images/hdf5_basic_tree.svg" src="../_images/hdf5_basic_tree.svg" width="60%" /></a>
</figure>
<p>From a very high level point of view we can assume that there are two kind
of objects</p>
<ol class="arabic simple">
<li><p>container objects (<em>Group</em>) which can store links to other object</p></li>
<li><p>leafe like objects which cannot hold links to other objects
(<em>Datasets</em> and <em>committed Datatypes</em>).</p></li>
</ol>
<p>Technically, we can refer to all of these objects as <em>nodes</em> and thus consider
an HDF5 tree as a collection of <em>nodes</em> connected by <em>links</em>. <em>h5cpp</em> maps
this hierachy of node types rather straight forward onto C++ classes like this</p>
<figure class="align-center" id="id5">
<a class="reference internal image-reference" href="../_images/node_types.svg"><img alt="../_images/node_types.svg" src="../_images/node_types.svg" width="60%" /></a>
<figcaption>
<p><span class="caption-text">Hierarchy of node types in <em>h5cpp</em>.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>with <a class="reference internal" href="../api_reference/namespace_node.html#_CPPv4N4hdf54node4NodeE" title="hdf5::node::Node"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Node</span></code></a> being the top level class. The other classes
represent the following HDF5 objects:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 56%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><em>h5cpp</em> class</p></th>
<th class="head"><p>HDF5 type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="../api_reference/namespace_node.html#_CPPv4N4hdf54node7DatasetE" title="hdf5::node::Dataset"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Dataset</span></code></a></p></td>
<td><p>an HDF5 dataset</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../api_reference/namespace_node.html#_CPPv4N4hdf54node5GroupE" title="hdf5::node::Group"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Group</span></code></a></p></td>
<td><p>an HDF5 group</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Datatype</span></code></p></td>
<td><p>an HDF5 committed datatype</p></td>
</tr>
</tbody>
</table>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Do not confuse <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Datatype</span></code> with
<a class="reference internal" href="../api_reference/namespace_datatype.html#_CPPv4N4hdf58datatype8DatatypeE" title="hdf5::datatype::Datatype"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::datatype::Datatype</span></code></a>. Thoug the former one is constructed
from the latter one, the latter one cannot be accessed via a path.
A committed datatype is a means to store complex datatype within a file.</p>
</div>
<p>Each node can be augumented with attributes which can store meta-data related
to a node</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/hdf5_attributes.svg"><img alt="../_images/hdf5_attributes.svg" src="../_images/hdf5_attributes.svg" width="50%" /></a>
</figure>
<p>As attributes are common to all node types the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Manager</span></code> interface
providing access to them is already exposed on the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Node</span></code> class.</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="../_images/node.svg"><img alt="../_images/node.svg" src="../_images/node.svg" width="60%" /></a>
<figcaption>
<p><span class="caption-text">Attributes are accessd via an attribute manager associated with each
node instance.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>To understand why every instance of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Node</span></code> also stores an instance
of <a class="reference internal" href="../api_reference/namespace_node.html#_CPPv4N4hdf54node4LinkE" title="hdf5::node::Link"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Link</span></code></a> we need to have a closer look on links</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/hdf5_links.svg"><img alt="../_images/hdf5_links.svg" src="../_images/hdf5_links.svg" width="75%" /></a>
</figure>
<p>There are actually three kinds of links connecting objects within a file</p>
<ul class="simple">
<li><p><em>hard links</em> which are created when a new object is created in a file</p></li>
<li><p><em>soft links</em> which can be used liks symbolic links on a file system to
provide alternative means of access to an object</p></li>
<li><p><em>external links</em> providing a means to reference objects from a different
file.</p></li>
</ul>
<p>This concept introduces some kind of ambiguity as can be seen from the
figure above. There are basically three tracks which lead to the same
<em>Dataset</em> instance. This is a known problem in the HDF5 library and <em>h5cpp</em>
has taken a rather pragmatic approach how to solve it as will be shown later.</p>
<p>Furthermore it is important to note that <em>Nodes</em> in an HDF5 file do not have
names. This is an unfortunate widespread misconception about HDF5. <em>Nodes</em>
can be accessed via a list of named links starting at the root node (root group)
of a file but the <em>Nodes</em> themeselfes have no idea about a name.
Which would not even make sense if we take the ambiguity shown above into
account. Which of the three link chains leading to the <em>Dataset</em> instance
would be the correct name of the <em>Dataset</em>?</p>
<p>We have chosen a rather pragmatic approach to solve this naming problem
in <em>h5cpp</em>. However, before we can discuss this we have to take a little
detour and introduce some more classes.</p>
<p>The list of link names used to access a particular object is in general
refered to as the path to an object. <em>h5cpp</em> thus has a class
<a class="reference internal" href="../api_reference/namespace_hdf5.html#_CPPv4N4hdf54PathE" title="hdf5::Path"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::Path</span></code></a> which represents such a list of link names.
The string representation of a path looks quite like a Unix filesystem path.
It is the list of names separated by <cite>/</cite>. In the above example two possible
paths to the <em>Dataset</em> would be</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/sensors/temp
/plot/y
</pre></div>
</div>
<p>Like for a Unix filesystem path an HDF5 path can be either absolute (starting
with a <code class="docutils literal notranslate"><span class="pre">/</span></code> and thus at the root node of a given file) or relative to a
particular node (no <code class="docutils literal notranslate"><span class="pre">/</span></code> at the beginning).</p>
<p>To represent links <em>h5cpp</em> provides the <a class="reference internal" href="../api_reference/namespace_node.html#_CPPv4N4hdf54node4LinkE" title="hdf5::node::Link"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Link</span></code></a> class</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/h5cpp_link.svg"><img alt="../_images/h5cpp_link.svg" src="../_images/h5cpp_link.svg" width="50%" /></a>
</figure>
<p>As shown in this UML diagram <a class="reference internal" href="../api_reference/namespace_node.html#_CPPv4N4hdf54node4LinkE" title="hdf5::node::Link"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::node::Link</span></code></a> stores a reference
to the file where the link resides in and the path. In other words, the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Link</span></code> class is a complete roadmap to a particular node.</p>
<p>Now, as shown previously, every <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Node</span></code> also stores a reference
to an instance of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Link</span></code>. This is the link (in particular the path)
used to access the node. We thus solved the name ambiguity of an object by
defining its name as the link (and thus the path) used to access the object.
With this we are now able to ask a node for its name (path) and expect
the path used to access the node.</p>
<section id="node-ids">
<h4>Node IDs<a class="headerlink" href="#node-ids" title="Permalink to this headline">¶</a></h4>
<p>After having solved the naming problem there is still an issue we have to solve.
In the figure above we have seen that there are many paths that could lead to
the same object. Now, if we do a recursive traversal over all nodes in a file
we would face the problem that we get a copy of the same node several times.
One for each path which leads to this object.
We thus introduced the concept of a unique ID which is associated with every
node. This ID identifies an object uniquely even over file boundaries and
remains constant once a node has been created within a particular file.
This ID is represented by the <a class="reference internal" href="../api_reference/namespace_hdf5.html#_CPPv4N4hdf58ObjectIdE" title="hdf5::ObjectId"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hdf5::ObjectId</span></code></a> class.
However, it is for internal use only and you usually do not have to care
about it.</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>If you are familiar with HDF5s C-API do not confuse the unique ID
introduced by <em>h5cpp</em> with the <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">hid_t</span></code> used in the C-API
to reference an instance of an object. The latter one is rather a handler
than an unqiue ID. IDs in <em>h5cpp</em> identify nodes uniquely even over
file boundaries at least within the context of a program.
While the value of <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">hid_t</span></code> can change after closing and
re-opening the same object <em>h5cpp</em>’s unique ID remains always the same.</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>What you should take from this section are</p>
<ul class="simple">
<li><dl class="simple">
<dt>an HDF5 file constists of <em>Nodes</em> which are</dt><dd><ul>
<li><p><em>Groups</em></p></li>
<li><p><em>Datasets</em></p></li>
<li><p><em>commited Datatypes</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>which are connected via <em>Links</em> from which there are three kinds</dt><dd><ul>
<li><p><em>hard links</em></p></li>
<li><p><em>soft links</em></p></li>
<li><p>and <em>external links</em></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>nodes can be augumented with <em>Attributes</em> which can be used to
store additional metadata about a <em>Node</em>.</p></li>
<li><p><em>Nodes</em> do not have names, <em>Links</em> have.</p></li>
<li><p><em>Paths</em> are lists of link names referencing a node within a file</p></li>
<li><p>every <em>Node</em> is associated with a unique ID which remains unique
even over file boundaries</p></li>
</ul>
</div>
</section>
</section>
<section id="data-io">
<h3>Data IO<a class="headerlink" href="#data-io" title="Permalink to this headline">¶</a></h3>
<p>Until now we have only considered structural aspects of an HDF5 file. The
second and most probably most important topic is data IO.
To understand how data IO works in HDF5 we first have to introduce a bit
terminology.</p>
<p>From a rather high level point of view the smallest unit of information which
can be accessed by HDF5 is a <em>data element</em>. Such a <em>data element</em> can be
everything ranging from a  single integer number up to complex types
consisting of nested C-structs or C++ classes. A <em>data element</em> is stored in
memory and/or on disk as a set of bits. In order to interpret these bits
correctly and reassemble the stored <em>data element</em> we need some information
about it. This information is provided in HDF5 by a <em>datatype</em>.</p>
<p><em>Data elements</em> have some logical organization. For instance we can
store these elements in a 2 dimensional array.</p>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="../_images/dataspace_high_level.svg"><img alt="../_images/dataspace_high_level.svg" src="../_images/dataspace_high_level.svg" width="75%" /></a>
<figcaption>
<p><span class="caption-text"><em>data elements</em> of 3 numbers (could be a 3D vector) are stored in a
2 dimensional array with 5 elements along the first and 3 elements
along the second dimensions.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>The logical layout of <em>data elements</em> is described by a <em>dataspace</em>.
Currently there are only two <em>dataspaces</em> available in HDF5</p>
<ul class="simple">
<li><p>a <em>scalar</em> space which can store only a single element</p></li>
<li><p>and a <em>simple</em> space which is a regular n-dimensional array
(as the one above).</p></li>
</ul>
<p><em>Dataspaces</em> and <em>datatypes</em> are the fundamental building blocks of all
objects that can store data within an HDF5 file</p>
<ul class="simple">
<li><p><em>attributes</em></p></li>
<li><p>and <em>datasets</em></p></li>
</ul>
<p>For the construction of either of them you have to provide a <em>datatype</em> and
a <em>dataspace</em>. As a matter of fact, <em>attributes</em> and <em>datasets</em> are quite
similar, though a <em>dataset</em> is a <em>node</em> type and can be accessed via a
<em>path</em>. In addition, <em>datasets</em> are far more flexible than <em>attributes</em> as
we will see soon.</p>
<p>We need to introduce the term <em>storage</em> as a rather abstract region of space
where we can store data and which is contiguous and linear addressable.
Technically such a <em>storage</em> can be implemented either</p>
<ul class="simple">
<li><p>in memory (as a contiguous region of memory)</p></li>
<li><p>or on disk</p></li>
</ul>
<p>where in the latter case it is not important for us how exactly the data
is stored on disk (as a single block of data within a file or scattered
over several blocks within a file).</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/storage_models.svg"><img alt="../_images/storage_models.svg" src="../_images/storage_models.svg" width="60%" /></a>
</figure>
<p>We never have to care about the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DiskStorage</span></code> this is done by the
HDF5 library. However, in some cases we need to care about the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemoryStorage</span></code>. As far as it concerns this chapter we can consider
both to satisfiy the above constraints.</p>
<p>We will have a look now how data transfer roughly works by using the above
example. For the dataset under consideration we have</p>
<ul class="simple">
<li><p>a datatype comprising 3 double valus (3x8Bytes) and thus a total size of
24 Bytes</p></li>
<li><p>and a dataspace of shape (3,5) where the last index varies fastest.</p></li>
</ul>
<p>The <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemoryStorage</span></code> of such a dataset would look like this</p>
<figure class="align-center">
<a class="reference internal image-reference" href="../_images/memory_storage_example.svg"><img alt="../_images/memory_storage_example.svg" src="../_images/memory_storage_example.svg" width="65%" /></a>
</figure>
<p>Every data element occupies 24Byte. The numbers on the very left denote the
memory offset in byte for the very left byte in the block. In the above figure
the elements are represented in a 3x5 matrix to preserve space but in memory
they would be aligend simply one after the other.
It is the dataspace which associates the linear region of memory with a
particular shape. By default C-style ordering, last index variest fastest,
is used. As a matter of fact it is the job of the dataspace to map the
multidimensional index of a particular element onto a linear address in the
storage area.</p>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>add a figure here!</p>
</div>
<p>When data is written to disk, the content of the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">MemoryStorage</span></code>
is transfered to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">DiskStorage</span></code>. It is important to note that
the dataspace of the latter one must not be equal to that of the memory storage.
They must only have equal size (number of data elements). In addition, the
data elements in memory must be convertable to those associated with the
file storage. The same is true for the other direction when reading data
from the disk.</p>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>add a figure here!</p>
</div>
<section id="selections-and-partial-io">
<h4>Selections and partial IO<a class="headerlink" href="#selections-and-partial-io" title="Permalink to this headline">¶</a></h4>
<p>One of the nice features of HDF5 is that we do not have to read or write the
entire data from or to the disk. This is paticularly usefull if the total
amount of data available in a dataset would not fit in the memory of the
computer which wants to access the data.
We can distinguish between</p>
<ul class="simple">
<li><p><em>point selections</em> where individual data elements can be picked in an
arbitrary pattern</p></li>
<li><p>and <em>hyperslab selections</em> which are regular multidimensional <em>slices</em>.
<em>Hyperslabs</em> roughly compare to what you can do with array indices and
slices on numpy arrays in Python.</p></li>
</ul>
<p>With a point selection we could for instance read the elements
(0,2), (1,3) and (2,0) and store them in a either a new memory storage of
size 3 (which would be 72Bytes in total) or in a more sophisticated setup
we could map them on points (0),(5) and (11) in a 1D array in memory.</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>add a figure here</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The following concepts are important and thus should be kept in mind
for further reading</p>
<ul class="simple">
<li><p>a <em>Datatype</em> describes a single data element (no matter how complex it
might be)</p></li>
<li><p>a <em>Dataspace</em> describes how data elemets are layed out in memory</p></li>
<li><p>all data is store in <em>Dataspaces</em> and <em>Attributes</em> (the interfaces are
quite simliar but attributes have some limitations)</p></li>
<li><p><em>Selections</em> make it possible to read only a particular part of a
<em>Dataset</em></p></li>
</ul>
</div>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Design overview</a><ul>
<li><a class="reference internal" href="#h5cpp-namespaces"><em>h5cpp</em> namespaces</a></li>
<li><a class="reference internal" href="#a-high-level-view-on-hdf5">A high level view on HDF5</a><ul>
<li><a class="reference internal" href="#nodes-links-and-paths">Nodes, links, and paths</a><ul>
<li><a class="reference internal" href="#node-ids">Node IDs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-io">Data IO</a><ul>
<li><a class="reference internal" href="#selections-and-partial-io">Selections and partial IO</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="using.html"
                        title="previous chapter">Using the library</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="files.html"
                        title="next chapter">Working with files</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><p>
  <h3 class='versions'>Versions</h3>
  <p>
    <ul>
      <li><a class="reference external" href="../index/../../latest/index.html">v:latest</a></li>
      <li><a class="reference external" href="../index/../../stable/index.html">v:stable</a></li>
      
      <li><a class="reference external" href="../index/../../v0.4.1/index.html">v0.4.1</a></li>
      <li><a class="reference external" href="../index/../../v0.3.3/index.html">v0.3.3</a></li>
      
    </ul>
  </p>
</p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="files.html" title="Working with files"
             >next</a> |</li>
        <li class="right" >
          <a href="using.html" title="Using the library"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">h5cpp 0.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Users guide</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Design overview</a></li> 
      </ul>
    </div>
<li>generated on 2022-02-15 15:29:35 from  (278d88e)</li>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Deutsches Elektronen-Synchrotron, European Spallation Source ERIC; generated on 2022-02-15 15:29:35 from  (278d88e).
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.3.
    </div>

  </body>
</html>